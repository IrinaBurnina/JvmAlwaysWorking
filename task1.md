# Работа Java Virtual Machine

```java
public class JvmComprehension {

    public static void main(String[] args) {
        int i = 1;                      // 1
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  // 6
    }
}
```
### Ответ:

Сперва срабатывает первый этап JVM - ClassLoader, 
требуется подгрузка класса JvmComprehension, Object(-для строки №2 и №6), Integer (-для строки №3 и №5). Подгрузка происходит в метаспейс и может быть согласно схеме

![Bootstrap Classloader -> Platform Classloader -> Application Classloader](//Users/%D0%98%D1%80%D0%B0/Desktop/%D0%94%D0%B6%D0%B0%D0%B2%D0%B0/%D0%94%D0%BE%D0%BC%D0%B0%D1%88%D0%BA%D0%B0/%D0%A1%D1%85%D0%B5%D0%BC%D0%B0%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%BB%D0%BE%D0%B0%D0%B4%D0%B5%D1%80%D0%BE%D0%B2.png//700*900)

либо пользовательской со своим набором ClassLoader.
По представленной схеме проверяются группы классов для загрузки на соответствие представленному
классу JvmComprehesion в следующей последовательности с делегированием очередности: Bootstrap ClassLoader,
Platform ClassLoader, Application ClassLoader.

После загрузки классов происходит проверка корректности байт-кода, а также 
проверка: не были ли загружены эти классы ранее. Далее создаются экземпляры
 этих классов. Затем подгружаются родительские классы.

Происходит связывание подгруженных классов: предварительно 
проверяется (Verify) корректность байт-кода, затем осуществляется подготовка  (Prepare)
к связыванию, а именно: 

    выделение оперативной памяти в стеке для статических полей (в нашем это два статических метода? и примитивы в строке №1) (-начнет свою работу Runtime Data Area). Затем происходит инициализация этих полей по умолчанию. Далее проходит Resolve - разрешение символьных ссылок на другие классы. Следующим этапом выступает инициализация классов, чтобы потом JVM могла начать выполнение байт-кода.

В момент вызова метода main в памяти стека создается фрейм, в который затем помещается строка №1, а класс объекта строки №2 и 3 помещается в кучу и хранится там, сами объекты этих классов помещаются во фрейм метода main в стеке.
На строке №4 создается следующий фрейм уже для метода printAll. Класс строки № 5 уже есть в куче, а его объект помещается во фрейм метода printAll в стеке.
Строка №6 - создастся новый фрейм в стеке со ссылкой на объекты о, i, ii. Аналогично строка №7.

#### Execution Engine/Garbage collection
Строка №5 не содержит ссылки ни на один объект и является не достижимым объектом. Поэтому подлежит удалению при сборке мусора. 
